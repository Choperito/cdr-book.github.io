<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Capítulo 9 Selección y transformación de variables | Fundamentos de ciencia de datos con R</title>
<meta name="author" content="Gema Fernández-Avilés y José-María Montero">
<meta name="description" content="Jorge Velasco López\(^{a}\) y José-María Montero\(^{b}\) \(^{a}\)Instituto Nacional de Estadística de España \(^{b}\)Universidad de Castilla-La Mancha  9.1 Introducción Como se indicó en el Cap....">
<meta name="generator" content="bookdown 0.34 with bs4_book()">
<meta property="og:title" content="Capítulo 9 Selección y transformación de variables | Fundamentos de ciencia de datos con R">
<meta property="og:type" content="book">
<meta property="og:image" content="/img/cover.png">
<meta property="og:description" content="Jorge Velasco López\(^{a}\) y José-María Montero\(^{b}\) \(^{a}\)Instituto Nacional de Estadística de España \(^{b}\)Universidad de Castilla-La Mancha  9.1 Introducción Como se indicó en el Cap....">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Capítulo 9 Selección y transformación de variables | Fundamentos de ciencia de datos con R">
<meta name="twitter:description" content="Jorge Velasco López\(^{a}\) y José-María Montero\(^{b}\) \(^{a}\)Instituto Nacional de Estadística de España \(^{b}\)Universidad de Castilla-La Mancha  9.1 Introducción Como se indicó en el Cap....">
<meta name="twitter:image" content="/img/cover.png">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.4.2/transition.js"></script><script src="libs/bs3compat-0.4.2/tabs.js"></script><script src="libs/bs3compat-0.4.2/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><link href="libs/tabwid-1.1.3/tabwid.css" rel="stylesheet">
<script src="libs/tabwid-1.1.3/tabwid.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><link rel="stylesheet" href="bs4_style.css">
<link rel="stylesheet" href="bs4_book.css">
<link rel="stylesheet" href="style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Fundamentos de ciencia de datos con R</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Buscar" aria-label="Buscar">
</form>

      <nav aria-label="Contenido"><h2>Contenido</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Prefacio</a></li>
<li class="book-part">Ciencia, datos, software… y científicos</li>
<li><a class="" href="ciencia-datos.html"><span class="header-section-number">1</span> ¿Es la ciencia de datos una ciencia?</a></li>
<li><a class="" href="metodologia.html"><span class="header-section-number">2</span> Metodología en ciencia de datos</a></li>
<li><a class="" href="ch-110003.html"><span class="header-section-number">3</span> R para ciencia de datos</a></li>
<li><a class="" href="cap-etica.html"><span class="header-section-number">4</span> Ética en la ciencia de datos</a></li>
<li class="book-part">Bienvenidos a la jungla de datos</li>
<li><a class="" href="datos-sql.html"><span class="header-section-number">5</span> Gestión de bases de datos relacionales</a></li>
<li><a class="" href="cap-nosql.html"><span class="header-section-number">6</span> Gestión de bases de datos NoSQL</a></li>
<li><a class="" href="DGDQM.html"><span class="header-section-number">7</span> Gobierno, gestión y calidad del dato</a></li>
<li><a class="" href="id_130009.html"><span class="header-section-number">8</span> Integración y limpieza de datos</a></li>
<li><a class="active" href="chap-feature.html"><span class="header-section-number">9</span> Selección y transformación de variables</a></li>
<li><a class="" href="chap-herramientas.html"><span class="header-section-number">10</span> Herramientas para el análisis en ciencia de datos</a></li>
<li><a class="" href="id_120006-aed.html"><span class="header-section-number">11</span> Análisis exploratorio de datos</a></li>
<li class="book-part">Fundamentos de estadística</li>
<li><a class="" href="Funda-probab.html"><span class="header-section-number">12</span> Probabilidad</a></li>
<li><a class="" href="Fundainfer.html"><span class="header-section-number">13</span> Inferencia estadística</a></li>
<li><a class="" href="muestreo.html"><span class="header-section-number">14</span> Muestreo y remuestreo</a></li>
<li class="book-part">Modelización estadística</li>
<li><a class="" href="cap-lm.html"><span class="header-section-number">15</span> Modelización lineal</a></li>
<li><a class="" href="cap-glm.html"><span class="header-section-number">16</span> Modelos lineales generalizados</a></li>
<li><a class="" href="cap-gam.html"><span class="header-section-number">17</span> Modelos aditivos generalizados</a></li>
<li><a class="" href="cap-mxm.html"><span class="header-section-number">18</span> Modelos mixtos</a></li>
<li><a class="" href="cap-sparse.html"><span class="header-section-number">19</span> Modelos sparse y métodos penalizados de regresión</a></li>
<li><a class="" href="cap-series-temp.html"><span class="header-section-number">20</span> Modelización de series temporales</a></li>
<li><a class="" href="cap-discriminante.html"><span class="header-section-number">21</span> Análisis discriminante</a></li>
<li><a class="" href="cap-conjunto.html"><span class="header-section-number">22</span> Análisis conjunto</a></li>
<li><a class="" href="tablas-contingencia.html"><span class="header-section-number">23</span> Análisis de tablas de contingencia</a></li>
<li class="book-part">Machine learning supervisado</li>
<li><a class="" href="cap-arboles.html"><span class="header-section-number">24</span> Árboles de clasificación y regresión</a></li>
<li><a class="" href="cap-svm.html"><span class="header-section-number">25</span> Máquinas de vector soporte</a></li>
<li><a class="" href="cap-knn.html"><span class="header-section-number">26</span> Clasificador k-vecinos más próximos</a></li>
<li><a class="" href="cap-naive-bayes.html"><span class="header-section-number">27</span> Naive Bayes</a></li>
<li><a class="" href="cap-bagg-rf.html"><span class="header-section-number">28</span> Métodos ensamblados: bagging y random forest</a></li>
<li><a class="" href="cap-boosting-xgboost.html"><span class="header-section-number">29</span> Boosting y el algoritmo XGBoost</a></li>
<li class="book-part">Machine learning no supervisado</li>
<li><a class="" href="jerarquico.html"><span class="header-section-number">30</span> Análisis cluster: clusterización jerárquica</a></li>
<li><a class="" href="no-jerarquico.html"><span class="header-section-number">31</span> Análisis cluster: clusterización no jerárquica</a></li>
<li><a class="" href="acp.html"><span class="header-section-number">32</span> Análisis de componentes principales</a></li>
<li><a class="" href="an%C3%A1lisis-factorial.html"><span class="header-section-number">33</span> Análisis factorial</a></li>
<li><a class="" href="escalamiento-multidimensional.html"><span class="header-section-number">34</span> Escalamiento multidimensional</a></li>
<li><a class="" href="correspondencias.html"><span class="header-section-number">35</span> Análisis de correspondencias</a></li>
<li class="book-part">Deep learning</li>
<li><a class="" href="capNN.html"><span class="header-section-number">36</span> Redes neuronales artificiales</a></li>
<li><a class="" href="cap-redes-convol.html"><span class="header-section-number">37</span> Redes neuronales convolucionales</a></li>
<li class="book-part">Ciencia de datos de texto y redes</li>
<li><a class="" href="mineria-textos.html"><span class="header-section-number">38</span> Minería de textos</a></li>
<li><a class="" href="grafos.html"><span class="header-section-number">39</span> Análisis de grafos y redes sociales</a></li>
<li class="book-part">Ciencia de datos espaciales</li>
<li><a class="" href="datos-espaciales.html"><span class="header-section-number">40</span> Trabajando con datos espaciales</a></li>
<li><a class="" href="geo.html"><span class="header-section-number">41</span> Geoestadística</a></li>
<li><a class="" href="cap-econom-esp.html"><span class="header-section-number">42</span> Modelos econométricos espaciales</a></li>
<li><a class="" href="cap-pp.html"><span class="header-section-number">43</span> Procesos de puntos</a></li>
<li class="book-part">Comunica y colabora</li>
<li><a class="" href="id_120007-informes.html"><span class="header-section-number">44</span> Informes reproducibles con R Markdown y Quarto</a></li>
<li><a class="" href="shiny.html"><span class="header-section-number">45</span> Creación de aplicaciones web interactivas con Shiny</a></li>
<li><a class="" href="github.html"><span class="header-section-number">46</span> Git y GitHub R</a></li>
<li><a class="" href="geoproces.html"><span class="header-section-number">47</span> Geoprocesamiento en nube</a></li>
<li class="book-part">Casos de estudio en ciencia de datos</li>
<li><a class="" href="cap-crimen.html"><span class="header-section-number">48</span> Análisis de una red criminal</a></li>
<li><a class="" href="cap-publicidad.html"><span class="header-section-number">49</span> Optimización de inversiones publicitarias</a></li>
<li><a class="" href="cap-twitter.html"><span class="header-section-number">50</span> ¿Cómo twitea Elon Musk?</a></li>
<li><a class="" href="cap-periodismo.html"><span class="header-section-number">51</span> Análisis electoral: de Rstudio a su periódico</a></li>
<li><a class="" href="paro-clm.html"><span class="header-section-number">52</span> Crisis: impacto en el paro de Castilla-La Mancha</a></li>
<li><a class="" href="cap-rfm.html"><span class="header-section-number">53</span> Segmentación de clientes en el comerico minorista</a></li>
<li><a class="" href="cap-medicina.html"><span class="header-section-number">54</span> Análisis de datos en medicina</a></li>
<li><a class="" href="cap-futbol.html"><span class="header-section-number">55</span> Messi y Ronaldo: dos ídolos desde la perspectiva de los datos</a></li>
<li><a class="" href="cambioclimatico.html"><span class="header-section-number">56</span> Un dato sobre el cambio climático</a></li>
<li><a class="" href="cap-ree.html"><span class="header-section-number">57</span> Predicción de consumo eléctrico con redes neuronales</a></li>
<li><a class="" href="cap-sist-exp.html"><span class="header-section-number">58</span> Implementación de un sistema experto en el ámbito pediátrico</a></li>
<li><a class="" href="nlp-textil.html"><span class="header-section-number">59</span> El procesamiento del lenguaje natural para tendencias de moda en textil</a></li>
<li><a class="" href="cap-fraude.html"><span class="header-section-number">60</span> Detección de fraude de tarjetas de crédito</a></li>
<li class="book-part">Appendix</li>
<li><a class="" href="info-session.html"><span class="header-section-number">A</span> Información de la sesión</a></li>
<li><a class="" href="referncias.html">Referncias</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="chap-feature" class="section level1" number="9">
<h1>
<span class="header-section-number">Capítulo 9</span> Selección y transformación de variables<a class="anchor" aria-label="anchor" href="#chap-feature"><i class="fas fa-link"></i></a>
</h1>
<p><em>Jorge Velasco López</em><span class="math inline">\(^{a}\)</span> y <em>José-María Montero</em><span class="math inline">\(^{b}\)</span></p>
<p><span class="math inline">\(^{a}\)</span>Instituto Nacional de Estadística de España
<span class="math inline">\(^{b}\)</span>Universidad de Castilla-La Mancha</p>
<div id="introducción-4" class="section level2" number="9.1">
<h2>
<span class="header-section-number">9.1</span> Introducción<a class="anchor" aria-label="anchor" href="#introducci%C3%B3n-4"><i class="fas fa-link"></i></a>
</h2>
<p>Como se indicó en el Cap. <a href="#130009"><strong>??</strong></a>, la preparación de datos, en un contexto de ciencia de datos, consiste en transformarlos de tal forma que se puedan utilizar adecuadamente en las fases posteriores de modelado. Esta preparación o pre-preprocesamiento puede ser un proceso laborioso e incluye tareas como la integración y limpieza de datos, que se detallaron en dicho capítulo.</p>
<p>El presente capítulo aborda las tareas relativas a la <strong>selección de variables</strong> (<em>feature selection</em>) y <strong>transformación de variables</strong>.
La selección de variables tiene como objetivo elegir el elenco de variables más relevantes para el análisis. La transformación de variables hace referencia, básicamente, al uso de determinados procedimientos para modificar la distribución de la variable objetivo, a la ingeniería de variables (<em>feature engineering</em>), a normalización y a la reducción de la dimensionalidad del problema de interés.</p>
<p>
</p>
<p>Se usará el conjunto de datos <code>Madrid_Sale</code> (disponibles en el paquete de <strong>R</strong> <code>Idealista18</code>), con datos inmobiliarios del año 2018 para el municipio de Madrid, y los paquetes <code>caret</code> <span class="citation">(<a href="referncias.html#ref-kuhn2008building" role="doc-biblioref">Kuhn 2008</a>)</span>, para diversas tareas de preparación de datos y <code>corrplot</code> <span class="citation">(<a href="referncias.html#ref-wei2017package" role="doc-biblioref">Wei et al. 2017</a>)</span>, para visualizar correlaciones, entre otros.</p>
</div>
<div id="feature" class="section level2" number="9.2">
<h2>
<span class="header-section-number">9.2</span> Selección de variables<a class="anchor" aria-label="anchor" href="#feature"><i class="fas fa-link"></i></a>
</h2>
<p> </p>
<p>Quizás, el primer gran reto al que se enfrenta el científico de datos cuando maneja grandes conjuntos de datos es la identificación de las variables que proporcionen información valiosa sobre la variable objetivo, bien se trate de un problema de regresión o de clasificación. En caso de que el científico de datos salga exitoso de este primer gran reto, un determinado subconjunto de variables del conjunto de datos de interés proporcionará la misma información sobre la variable objetivo que la totalidad de variables incluidas en el conjunto de datos.</p>
<p>En consecuencia, la selección de variables involucra un conjunto de técnicas cuyo objetivo es seleccionar el subconjunto de variables predictoras más relevante para las fases de modelización. Esto es importante porque:</p>
<ul>
<li>Variables predictoras redundantes pueden distraer o engañar a los algoritmos de aprendizaje, lo que posiblemente se traduzca en un menor rendimiento, no solo predictivo (exactitud y precisión), sino también en términos de tiempo de computación.</li>
<li>Igualmente, la inclusión de variables irrelevantes aumenta el coste computacional y dificulta la interpretabilidad.</li>
</ul>
<p>
</p>
<p>Una adecuada selección de variables tiene ventajas importantes: <span class="math inline">\((i)\)</span> elimina las variables con información redundante; <span class="math inline">\((ii)\)</span> reduce el grado de complejidad de los modelos; <span class="math inline">\((iii)\)</span> evita o reduce el sobreajuste; <span class="math inline">\((iv)\)</span> incrementa de la precisión de las predicciones; y <span class="math inline">\((iv)\)</span> reduce la carga computacional.</p>
<p>No obstante, es importante señalar que, antes de llevarse a cabo la selección de variables propiamente dicha, debe comprobarse la magnitud de la varianza de las variables candidatas a ser seleccionadas y de sus correlaciones dos a dos, así como si existen combinaciones lineales entre ellas (multicolinealidad). Y ello, porque estas tres comprobaciones sirven para realizar una primera pre-selección de variables, si bien por razones técnicas y no de capacidad de explicación del comportamiento de la variable respuesta.</p>
<p>Los métodos de selección de variables (tras la pre-selección anteriormente mencionada) se suelen clasificar en: <span class="math inline">\((i)\)</span> los que utilizan la variable objetivo (supervisados); y <span class="math inline">\((ii)\)</span> los que no (no supervisados). Debido a la complejidad de la cuestión, se pasará revista únicamente a los métodos supervisados más relevantes, que se pueden dividir en:</p>
<ul>
<li><p><strong>Métodos tipo filtro</strong>, que puntúan de mayor a menor cada variable predictora en base a su capacidad predictiva y seleccionan un subconjunto de ellas en base a dichas puntuaciones <span class="citation">(<a href="referncias.html#ref-brownlee2020data" role="doc-biblioref">Brownlee 2020</a>)</span>.</p></li>
<li><p><strong>Métodos tipo envoltura</strong> (<em>wrapper</em>), que eligen el subconjunto de variables que dan como resultado el modelo con mayores prestaciones en cuanto a calidad de resultados y eficiencia: error de predicción o clasificación, precisión, tiempo de computación…</p></li>
<li><p><strong>Métodos intrínsecos</strong> (o <em>embedded</em>), que seleccionan las variables automáticamente como parte del ajuste del modelo durante el entrenamiento (tal es el caso de algunos modelos de regresión penalizados, como Lasso, árboles de decisión y bosques aleatorios (<em>random forests</em>)).</p></li>
</ul>
<p>
</p>
<div id="pre-selección-de-variables" class="section level3" number="9.2.1">
<h3>
<span class="header-section-number">9.2.1</span> Pre-selección de variables<a class="anchor" aria-label="anchor" href="#pre-selecci%C3%B3n-de-variables"><i class="fas fa-link"></i></a>
</h3>
<div id="salenum" class="section level4" number="9.2.1.1">
<h4>
<span class="header-section-number">9.2.1.1</span> Varianza nula<a class="anchor" aria-label="anchor" href="#salenum"><i class="fas fa-link"></i></a>
</h4>
<p>
</p>
<p>Uno de los aspectos fundamentales en la selección de variables es comprobar si su varianza es cero o cercana a cero porque, si es así, sus valores son iguales o similares, respectivamente, y, por tanto, esas variables estarán perfectamente o cuasi-perfectamente correladas con el término independiente del modelo, con lo cual, en el mejor de los casos, solo añadirán ruido al modelo. Además, este tipo de variables causan problemas a la hora de dividir el conjunto de datos en subconjuntos de entrenamiento, validación y test. Las causas de una nula o muy pequeña variabilidad pueden estar en haber medido la variable en una escala inapropiada para la variable o en haber expandido una variable politómica en varias dicotómicas (una por categoría), entre otras. En el primer caso, un cambio de escala puede evitar el problema de la colinealidad. Otra opción más drástica la eliminación de la variable.</p>
<p>A continuación, se comprueba si las variables del conjunto de datos <code>Madrid_Sale</code> tienen <strong>varianza cero</strong>. Para ello se utiliza la función <code><a href="https://rdrr.io/pkg/caret/man/nearZeroVar.html">nearZeroVar()</a></code> del paquete <code>caret</code>.</p>
<p>Se seleccionan en primer lugar las variables numéricas en el conjunto de datos <code>Madrid_Sale_num</code>.</p>
<div class="sourceCode" id="cb105"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://paezha.github.io/idealista18/">"idealista18"</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://tidyverse.tidyverse.org">"tidyverse"</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://github.com/topepo/caret/">"caret"</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">Madrid_Sale</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame</a></span><span class="op">(</span><span class="va">Madrid_Sale</span><span class="op">)</span></span>
<span><span class="va">numeric_cols</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">sapply</a></span><span class="op">(</span><span class="va">Madrid_Sale</span>, <span class="va">is.numeric</span><span class="op">)</span></span>
<span><span class="va">Madrid_Sale_num</span> <span class="op">&lt;-</span> <span class="va">Madrid_Sale</span><span class="op">[</span>, <span class="va">numeric_cols</span><span class="op">]</span></span></code></pre></div>
<p>Se observa que se devuelve el valor <code>nzv=FALSE</code> (nzv: <em>near zero variance</em>) para casi todas las variables, con la excepción de <code>PARKINGSPACEPRICE, ISDUPLEX, ISSTUDIO, ISINTOPFLOOR</code> y <code>BUILTTYPEID_1</code>, que podrían descartarse como variables predictoras.</p>
<div class="sourceCode" id="cb106"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">varianza</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/caret/man/nearZeroVar.html">nearZeroVar</a></span><span class="op">(</span><span class="va">Madrid_Sale_num</span>, saveMetrics <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="co"># Con el argumento saveMetrics, se guardan los valores que se han utilizado para los cálculos.</span></span>
<span><span class="co"># Se muestran los primeros resultados</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">varianza</span>, <span class="fl">2</span><span class="op">)</span></span>
<span><span class="co">#&gt;       freqRatio  percentUnique   zeroVar   nzv</span></span>
<span><span class="co">#&gt; PERIOD  2.019617   0.004218742   FALSE   FALSE</span></span>
<span><span class="co">#&gt; PRICE   1.076923   2.911986500   FALSE   FALSE</span></span></code></pre></div>
<p>Para filtrar (excluir) las variables que se descartan como predictoras, se procede como sigue:</p>
<div class="sourceCode" id="cb107"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Madrid_Sale_num</span> <span class="op">&lt;-</span> <span class="va">Madrid_Sale_num</span><span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/select.html">select</a></span><span class="op">(</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">PARKINGSPACEPRICE</span>, <span class="va">ISDUPLEX</span>, <span class="va">ISSTUDIO</span>, <span class="va">BUILTTYPEID_1</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
</div>
<div id="correlación-entre-variables" class="section level4" number="9.2.1.2">
<h4>
<span class="header-section-number">9.2.1.2</span> Correlación entre variables<a class="anchor" aria-label="anchor" href="#correlaci%C3%B3n-entre-variables"><i class="fas fa-link"></i></a>
</h4>
<p>Como se avanzó anteriormente, otra de las cuestiones a tener en cuenta en el proceso de selección de variables es la magnitud de las <strong>correlaciones entre las variables</strong> candidatas, pues la existencia de correlaciones elevadas tiene consecuencias perversas sobre la fiabilidad de las predicciones (o de la clasificación realizada). En el caso extremo el modelo tendrá problemas de colinealidad o multicolinealidad (véase Sec. <a href="chap-feature.html#combinaciones-lineales">9.2.1.3</a>).</p>
<p></p>
<p>Para detectar las variables con muy elevada correlación entre ellas, se le pasa la función <code><a href="https://rdrr.io/pkg/caret/man/findCorrelation.html">findCorrelation()</a></code> de <code>caret</code>, con valor 0,9, a la matriz de correlaciones lineales entre las variables susceptibles de ser seleccionadas.</p>
<div class="sourceCode" id="cb108"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">madrid_cor</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span><span class="op">(</span><span class="va">Madrid_Sale_num</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">20</span><span class="op">]</span><span class="op">)</span> </span>
<span><span class="va">alta_corr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/caret/man/findCorrelation.html">findCorrelation</a></span><span class="op">(</span><span class="va">madrid_cor</span>, cutoff <span class="op">=</span> <span class="fl">.9</span><span class="op">)</span></span></code></pre></div>
<p>Con ello, se comprueba que la variable <code>HASPARKINGSPACE</code> tiene correlaciones superiores a 0,9 con varias de las variables predictoras, procediéndose a su eliminación.</p>
<div class="sourceCode" id="cb109"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Madrid_Sale_num</span> <span class="op">&lt;-</span> <span class="va">Madrid_Sale_num</span><span class="op">[</span>, <span class="op">-</span><span class="va">alta_corr</span><span class="op">]</span></span></code></pre></div>
<p>la Fig. <a href="chap-feature.html#fig:corr">9.1</a>, generada con el paquete <code>corrplot</code>, muestra las correlaciones existentes entre las primeras variables predictoras.</p>
<div class="sourceCode" id="cb110"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://github.com/taiyun/corrplot">"corrplot"</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">matriz_corr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span><span class="op">(</span><span class="va">Madrid_Sale_num</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">8</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/corrplot/man/corrplot.html">corrplot</a></span><span class="op">(</span><span class="va">matriz_corr</span>, method <span class="op">=</span> <span class="st">"circle"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:corr"></span>
<img src="img/corridealista.png" alt="Matriz de correlaciones topada en 0,9" width="60%"><p class="caption">
Figura 9.1: Matriz de correlaciones topada en 0,9
</p>
</div>
<p>Se aprecia que ya no hay variables altamente correlacionadas.</p>
</div>
<div id="combinaciones-lineales" class="section level4" number="9.2.1.3">
<h4>
<span class="header-section-number">9.2.1.3</span> Combinaciones lineales<a class="anchor" aria-label="anchor" href="#combinaciones-lineales"><i class="fas fa-link"></i></a>
</h4>
<p>En la práctica, en la mayoría de los casos, por ejemplo en las regresiones lineales, las variables que se utilizan como predictores no son ortogonales sino que tienen cierto grado de dependencia lineal entre ellas. Si dicho grado es moderado, las consecuencias de la no ortogonalidad en la predicción no son graves, pero en los casos de dependencia lineal cuasi-perfecta las inferencias resultantes del modelo estimado distan mucho de la realidad. Dichas consecuencias son aún más graves en el caso de que las combinaciones lineales sean perfectas. Por ello, la existencia de colinealidad o combinaciones lineales entre las variables seleccionables también es una circunstancia a evitar. En el caso de que los predictores (o varios de ellos) conformen una o varias combinaciones (o cuasi-combinaciones) lineales, no se puede conocer el impacto específico de cada uno de ellos en la variable objetivo, pues dichos impactos se solapan unos con otros. Además, como se ha avanzado, las predicciones no son fiables, entre otras cosas (véase <span class="citation">(<a href="#ref-pena2002analisis" role="doc-biblioref"><strong>pena2002analisis?</strong></a>)</span>). Y es que se le está pidiendo al conjunto de datos en estudio más información sobre la variable objetivo de la que realmente tiene. Entre otros modelos, la regresión lineal y la regresión logística parten del supuesto de no colinealidad o multicolinealidad entre las variables, por lo que no debería haber variables correlacionadas, ni dos a dos, ni en forma de combinación lineal entre varias de ellas.</p>
<p>
</p>
<p>Las principales fuentes de multicolinealidad son:
</p>
<ul>
<li>El método utilizado en la recogida de datos (subespacios).</li>
<li>Restricciones en el modelo o en la población (existencia de variables correlacionadas).</li>
<li>Especificación del modelo (polinomios).</li>
<li>Más variables que observaciones.</li>
</ul>
<p>En cuanto al detalle de las consecuencias más importantes de la multicolinealidad, hay que señalar las siguientes:</p>
<p></p>
<ul>
<li>Los estimadores tendrán grandes varianzas y covarianzas.</li>
<li>Las estimaciones de los coeficientes del modelos serán demasiado grandes.</li>
<li>Los signos de los coeficientes estimados suelen ser distintos a los esperados.</li>
<li>Pequeñas variaciones en los datos, o en la especificación del modelo, provocarán grandes cambios en los coeficientes.</li>
</ul>
<p>En el ejemplo con los datos del conjunto <code>Madrid_Sale</code> se utiliza la función <code><a href="https://rdrr.io/pkg/caret/man/findLinearCombos.html">findLinearCombos()</a></code> de <code>caret</code> para encontrar, en caso de que las haya, combinaciones lineales de las variables predictoras.</p>
<div class="sourceCode" id="cb111"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Madrid_Sale_num_na</span> <span class="op">&lt;-</span> <span class="fu">tidyr</span><span class="fu">::</span><span class="fu"><a href="https://tidyr.tidyverse.org/reference/drop_na.html">drop_na</a></span><span class="op">(</span><span class="va">Madrid_Sale_num</span><span class="op">)</span> <span class="co"># Es necesario eliminar los NA.</span></span>
<span><span class="va">combos</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/caret/man/findLinearCombos.html">findLinearCombos</a></span><span class="op">(</span><span class="va">Madrid_Sale_num_na</span><span class="op">)</span></span>
<span><span class="va">combos</span> </span>
<span><span class="co">#$remove</span></span>
<span><span class="co">#NULL</span></span></code></pre></div>
<p>Como puede comprobarse, no se encuentra ninguna combinación lineal en las variables numéricas de <code>Madrid_Sale</code>. En caso de existir, una solución al problema de la multicolinealidad pasa por:</p>
<ul>
<li><p>Eliminar variables predictoras que se encuentren altamente relacionadas con otras que permanecen en el modelo.</p></li>
<li><p>Sustituir las variables predictoras por componentes principales (véase Cap. <a href="acp.html#acp">32</a>).</p></li>
<li><p>Incluir información externa a los datos originales. Esta alternativa implica utilizar estimadores contraídos (de Stein o ridge) o bayesianos.</p></li>
</ul>
<p>A continuación se muestra, caso de existir, cómo se eliminarían las combinaciones lineales:</p>
<div class="sourceCode" id="cb112"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Madrid_Sale_num_na</span><span class="op">[</span>, <span class="op">-</span><span class="va">combos</span><span class="op">$</span><span class="va">remove</span><span class="op">]</span></span></code></pre></div>
</div>
</div>
<div id="métodos-de-selección-de-variables" class="section level3" number="9.2.2">
<h3>
<span class="header-section-number">9.2.2</span> Métodos de selección de variables<a class="anchor" aria-label="anchor" href="#m%C3%A9todos-de-selecci%C3%B3n-de-variables"><i class="fas fa-link"></i></a>
</h3>
<p>Tras la pre-selección de variables llevada a cabo en el epígrafe anterior, procede la selección de variables, propiamente dicha, de entre las que han superado la fase previa, en base, principalmente, a criterios de capacidad predictiva. No obstante, también se utilizan para:</p>
<ul>
<li>Simplificar de modelos para hacerlos más interpretables.</li>
<li>Mejorar la precisión del modelo (si se ha escogido bien el subconjunto de variables).</li>
<li>Reducir el tiempo de computación; sobre todo, entrenar algoritmos a mayor velocidad.</li>
<li>Evitar la maldición de la dimensionalidad (o efecto Huges), que se refiere a las consecuencias no deseadas que tienen lugar cuando la dimensionalidad de un problema es muy elevada.</li>
<li>Reducir la probabilidad de sobreajuste.</li>
</ul>
<div id="metfiltro" class="section level4" number="9.2.2.1">
<h4>
<span class="header-section-number">9.2.2.1</span> Métodos tipo filtro<a class="anchor" aria-label="anchor" href="#metfiltro"><i class="fas fa-link"></i></a>
</h4>
<p>
Los <strong>métodos de selección de variables tipo filtro</strong> usan técnicas estadísticas para evaluar la relación entre cada variable predictora (o de entrada, o independiente) y la variable objetivo (o de salida, o dependiente). Generalmente, consideran la influencia de cada variable predictora sobre la variable objetivo por separado. Las puntuaciones obtenidas se utilizan como base para clasificar y elegir las variables predictoras que se utilizarán en el modelo.</p>
<p>La elección de las técnicas estadísticas depende del tipo de variables (objetivo y predictoras). Por ejemplo, si las variables de entrada (predictoras) y salida (objetivo) fueran numéricas, se utilizaría
el coeficiente de correlación de Pearson o el de Spearman (dependiendo de si la relación entre la variable predictora y la variable objetivo es lineal o no) o el método de información mutua (véase <span class="citation">Vergara and Estévez (<a href="referncias.html#ref-vergara2014review" role="doc-biblioref">2014</a>)</span>). Si ambas fuesen categóricas, podrían usarse medidas de asociación para tablas de contingencia <span class="math inline">\(2\times 2\)</span> o <span class="math inline">\(R\times C\)</span> (véanse Sec. <a href="tablas-contingencia.html#medidas">23.4</a> y <a href="tablas-contingencia.html#medidas-rxc">23.5</a>). Si la de entrada fuese categórica y la de salida numérica, la técnica adecuada sería el Análisis de la Varianza (ANOVA, véase Sec. <a href="cap-lm.html#anova">15.4.6.1</a>). Si la categórica fuese la de salida y la numérica la de entrada, entonces habría que acudir a la regresión logística (véase Sec. <a href="#reg-logistica"><strong>??</strong></a>), por ejemplo. Sin embargo, el conjunto de datos no tiene porqué tener sólo un tipo de variable de entrada. Para manejar diferentes tipos de variables de entrada, se pueden seleccionar, por separado, variables de entrada numéricas y variables de entrada categóricas, usando en cada caso las técnicas apropiadas.</p>
<p>
</p>
<p>Estos métodos suelen eliminar sólo las variables de menor interés a la hora de predecir/clasificar. Permiten ahorrar tiempo y son especialmente robustos para el sobreaprendizaje. Sin embargo, no tienen en cuenta las relaciones entre las variables, lo que puede dar lugar a seleccionar variables redundantes si es que no se ha llevado a cabo una fase de pre-selección.</p>
<div class="infobox">
<p><strong>Nota</strong></p>
<p>Existen diversos paquetes, como <code>FSelector</code> <span class="citation">(<a href="referncias.html#ref-romanski2013package" role="doc-biblioref">Romanski, Kotthoff, and Kotthoff 2013</a>)</span> y el mismo <code>caret</code>, para implementar técnicas de selección de variables. Aquí se utiliza <code>FSinR</code>, que contiene una serie de métodos de filtro y envoltura, que se combinan con algoritmos de búsqueda para obtener el subconjunto óptimo de variables, usando funciones para entrenar modelos de clasificación y regresión disponibles en el paquete <code>caret</code>.
La selección de variables o características se lleva a cabo con la función <code>FeatureSelection()</code>, y la del algoritmo de búsqueda que se utilizará en el proceso de selección de funciones se realiza con la función <code>searchAlgorithm()</code>. Por su parte, los métodos de filtrado se implementan a través de la función <code>filterEvaluator()</code>.
No debe olvidarse que, antes de realizar el proceso de selección de variables, el usuario tiene que dividir el conjunto de datos convenientemente para llevar a cabo cada operación sobre el subconjunto correcto (véase Cap. <a href="chap-herramientas.html#chap-herramientas">10</a>). Igualmente, también de manera previa, se tiene que resolver el problema de los datos faltantes.</p>
</div>
<p>A continuación se muestra un ejemplo para variables predictoras numéricas. Para ello, se toma una muestra del conjunto de datos <code>Madrid_Sale_num</code>, obtenido en la Sec. <a href="chap-feature.html#salenum">9.2.1.1</a>. Una vez en disposición de la muestra, primeramente se transforma la variable objetivo en categórica, siendo las categorías (intervalos) cuatro cortes de la distribución de sus valores; dicha categorización se lleva a cabo mediante <strong>binning</strong>.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;&lt;em&gt;Binning&lt;/em&gt; (anglicismo que deriva de la palabra &lt;em&gt;bin&lt;/em&gt;: cubo, cesta, contenedor) es una técnica de discretización que agrupa datos numéricos en intervalos. Se suele utilizar para simplificar el análisis de datos continuos y aumentar la interpretabilidad del modelo, si bien a costa de reducir las combinaciones de las categorías de las variables predictoras que pueden realizarse, con lo cual el modelo sólo podrá hacer predicciones para unas pocas combinaciones de categorías de las variables predictoras.
El &lt;em&gt;binning&lt;/em&gt; puede ser supervisado o no (agrupamiento automático o manual). En este último caso, hay que tomar muchas precauciones porque, como señala &lt;span class="citation"&gt;Kuhn, Johnson, et al. (&lt;a href="referncias.html#ref-kuhn2013applied" role="doc-biblioref"&gt;2013&lt;/a&gt;)&lt;/span&gt;, &lt;span class="math inline"&gt;\((i)\)&lt;/span&gt; el &lt;em&gt;binning&lt;/em&gt; en las variables predictoras puede llevar a una pérdida significativa en la capacidad del modelo a la hora de determinar la relación (sobre todo si es compleja) entre los predictores y la variable objetivo; y &lt;span class="math inline"&gt;\((ii)\)&lt;/span&gt; en el entorno clasificatorio, puede dar lugar a una alta tasa de falsos positivos. Estas limitaciones pueden superarse en el caso de que el &lt;em&gt;binning&lt;/em&gt; se lleve a cabo de forma supervisada (tal es el caso de los árboles de regresión y clasificación y de la regresión adaptativa multivariante con splines), si bien debe tenerse en cuenta que, aunque se utilizan todos los predictores para llevar a cabo el proceso de &lt;em&gt;binning&lt;/em&gt;, la categorización está guiada por un único objetivo (por ejemplo, maximizar la exactitud).&lt;/p&gt;'><sup>66</sup></a> También se eliminan los registros con datos faltantes.</p>
<p></p>
<div class="sourceCode" id="cb113"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://rsample.tidymodels.org">"rsample"</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Se toma una muestra con el paquete rsample</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="va">Madrid_Sale_num_sample</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">Madrid_Sale_num</span><span class="op">)</span>, size <span class="op">=</span> <span class="fl">5000</span>, replace <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">Madrid_Sale_num_sample</span> <span class="op">&lt;-</span> <span class="va">Madrid_Sale_num</span><span class="op">[</span><span class="va">Madrid_Sale_num_sample</span>, <span class="op">]</span></span>
<span><span class="co"># Se realiza binning con cuatro bins</span></span>
<span><span class="va">Madrid_Sale_num_sample_bin</span> <span class="op">&lt;-</span> <span class="va">Madrid_Sale_num_sample</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html">mutate</a></span><span class="op">(</span>price_bin <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cut.html">cut</a></span><span class="op">(</span><span class="va">PRICE</span>, breaks <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">250000</span>, <span class="fl">500000</span>, <span class="fl">750000</span>, <span class="fl">10000000</span><span class="op">)</span>, labels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"primerQ"</span>, <span class="st">"segundoQ"</span>, <span class="st">"tercerQ"</span>, <span class="st">"c"</span><span class="op">)</span>, include.lowest <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/select.html">select</a></span><span class="op">(</span><span class="va">price_bin</span>, <span class="va">CONSTRUCTEDAREA</span>, <span class="va">ROOMNUMBER</span>, <span class="va">BATHNUMBER</span>, <span class="va">HASTERRACE</span>, <span class="va">HASLIFT</span><span class="op">)</span></span>
<span><span class="co"># Se eliminan los registros con valores missing</span></span>
<span><span class="va">Madrid_Sale_sample_na</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://tidyr.tidyverse.org/reference/drop_na.html">drop_na</a></span><span class="op">(</span><span class="va">Madrid_Sale_num_sample_bin</span><span class="op">)</span></span></code></pre></div>
<p>Una vez discretizada la variable objetivo, se selecciona el conjunto de variables predictoras de la variable objetivo <code>price_bin</code>, que es la variable <code>PRICE</code> transformada mediante <em>binning</em>. Como método tipo filtro se utiliza <code>minimum description length</code> (MDLM), que es un método de selección de variables que se basa en una medida de la complejidad del modelo denominada “longitud mínima de la descripción” (de ahí el nombre del modelo), por lo que su objetivo es encontrar el modelo más sencillo que proporcione una explicación aceptable de los datos. Como algoritmo de búsqueda se utiliza <code>sequential forward selection</code>.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Este método (selección hacia adelante) consiste en ajustar primero un modelo que contenga únicamente un término independiente (o intercepto); es decir, sin variables predictoras. Posteriormente, se ajusta otro con término independiente y una sola variable predictora. Después, se ajusta otro modelo con término independiente y dos variables predictoras. Y así sucesivamente. El criterio de parada suele ser que el valor del criterio de información de Akaike no experimente una reducción significativa al añadir una variable más al modelo. Los otros dos métodos o criterios para moverse en el espacio de búsqueda de subconjuntos de variables predictoras son el &lt;code&gt;backward&lt;/code&gt; (selección hacia atrás), que funciona justo al revés que el &lt;code&gt;forward&lt;/code&gt;, por eliminación de variables, y la selección paso a paso, &lt;code&gt;stepwise&lt;/code&gt; que es una combinación de los dos anteriores.&lt;/p&gt;"><sup>67</sup></a></p>
<div class="sourceCode" id="cb114"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st">"FSinR"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Método tipo filtro MDLC (Minimum-Description_Length-Criterion)</span></span>
<span><span class="va">evaluador</span> <span class="op">&lt;-</span> <span class="fu">filterEvaluator</span><span class="op">(</span><span class="st">"MDLC"</span><span class="op">)</span></span>
<span><span class="co"># Se genera el algoritmo de búsqueda</span></span>
<span><span class="va">buscador</span> <span class="op">&lt;-</span> <span class="fu">searchAlgorithm</span><span class="op">(</span><span class="st">"sequentialForwardSelection"</span><span class="op">)</span></span>
<span><span class="co"># Se implementa el proceso, pasando a la función los dos parámetros anteriores</span></span>
<span><span class="va">resultados</span> <span class="op">&lt;-</span> <span class="fu">featureSelection</span><span class="op">(</span><span class="va">Madrid_Sale_sample_na</span>, <span class="st">"price_bin"</span>, <span class="va">buscador</span>, <span class="va">evaluador</span><span class="op">)</span></span>
<span><span class="co"># Se muestran los resultados</span></span>
<span><span class="va">resultados</span><span class="op">$</span><span class="va">bestFeatures</span></span>
<span><span class="co">#&gt;      CONSTRUCTEDAREA ROOMNUMBER BATHNUMBER HASTERRACE HASLIFT</span></span>
<span><span class="co">#&gt; [1,]               0          0          0          1       0</span></span>
<span><span class="va">resultados</span><span class="op">$</span><span class="va">bestValue</span></span>
<span><span class="co">#&gt; [1] 355.3439</span></span></code></pre></div>
<p>En este caso, con los argumentos propuestos, el modelo seleccionado para explicar el comportamiento de la variable objetivo <code>price_bin</code> contiene únicamente el término independiente y una variable predictora: <code>HASTERRACE</code>.</p>
</div>
<div id="métodos-de-selección-de-variables-tipo-envoltura-wrapper" class="section level4" number="9.2.2.2">
<h4>
<span class="header-section-number">9.2.2.2</span> Métodos de selección de variables tipo envoltura (<em>wrapper</em>)<a class="anchor" aria-label="anchor" href="#m%C3%A9todos-de-selecci%C3%B3n-de-variables-tipo-envoltura-wrapper"><i class="fas fa-link"></i></a>
</h4>
<p>Este enfoque realiza una búsqueda a través de diferentes combinaciones o subconjuntos de variables predictoras/clasificadoras para comprobar el efecto que tienen en la precisión del modelo <span class="citation">(<a href="referncias.html#ref-saeys2007review" role="doc-biblioref">Saeys, Inza, and Larranaga 2007</a>)</span>.
</p>
<p>Hay varias alternativas:</p>
<ul>
<li>Evaluar las variables individualmente y seleccionar las <span class="math inline">\(n\)</span> variables principales que obtienen unas buenas prestaciones, aunque se pierde la información de las dependencias entre variables.</li>
<li>Observar el rendimiento del modelo para todas las combinaciones de variables posibles. En este sentido, se puede utilizar un algoritmo de búsqueda global estocástica, como los algoritmos genéticos que, si bien pueden ser efectivos, también pueden ser computacionalmente muy costosos.</li>
</ul>
<p>Los métodos <strong>wrapper</strong> son de gran eficacia a la hora de eliminar variables irrelevantes y/o redundantes (cosa que no ocurre en los de tipo filtro porque se centran en el poder predictor de cada variable de forma aislada). Además, tienen en cuenta la circunstancia de que dos o más variables, aparentemente irrelevantes en cuanto a su capacidad predictiva o clasificatoria cuando se consideran una por una, pueden ser relevantes cuando se consideran conjuntamente. Sin embargo, son muy lentos, ya que tienen que aplicar muchísimas veces el algoritmo de búsqueda, cambiando, cada vez, el número de variables, siguiendo, cada vez, algún criterio tanto de búsqueda como de paro. En lo que respecta a los criterios de búsqueda, estos son similares a los de los métodos tipo filtro. Por lo que se refiere a los criterios de paro, los usados en los métodos <em>wrapper</em> son menos eficientes que los criterios basados en algún tipo de medida de ganancia de información, distancia o consistencia, entre el predictor y la
variable objetivo (o clase) que utilizan los de tipo filtro.</p>
<div class="infobox">
<p><strong>Nota</strong></p>
<p>Las principales diferencias entre los métodos tipo filtro y tipo envoltura son las siguientes:</p>
<p>• Los métodos de filtro cuantifican la relevancia de las variables por su correlación con la variable salida, mientras que los métodos de tipo envoltura cuantifican las prestaciones del modelo para diferentes subconjuntos de variables.</p>
<p>• Los métodos de filtro tienen una carga computacional enormemente inferior a la de los envolventes, ya que no necesitan entrenar ningún modelo.</p>
<p>• Los métodos de filtro utilizan métodos estadísticos para evaluar la selección de variables; los de tipo envoltura utilizan métodos de validación cruzada.</p>
<p>• En la mayoría de ocasiones, la selección de variables realizada por los métodos tipo envoltura suele ser más exitosa que la proporcionada por los métodos de filtro.</p>
<p>• Los métodos de envoltura tienen una probabilidad de sobreajuste mucho mayor que los de filtro.</p>
</div>
<p>A continuación, sobre el conjunto de datos <code>Madrid_Sale_sample_na</code> y sobre la variable objetivo <code>price_bin</code> se establecen tanto los parámetros de los algoritmos de búsqueda como los métodos de filtrado y se calculan los resultados, usando para ello de <code>FSinR</code>. Como método de selección de variables se utiliza un método <strong>wrapper</strong> (con la función <code>wrapperEvaluator()</code>de <code>FSinR</code>) y como algoritmo de búsqueda <code>sequential forward selection</code>.</p>
<div class="sourceCode" id="cb115"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Se fijan los parámetros</span></span>
<span><span class="va">evaluador</span> <span class="op">&lt;-</span> <span class="fu">wrapperEvaluator</span><span class="op">(</span><span class="st">"rpart1SE"</span><span class="op">)</span></span>
<span><span class="va">buscador</span> <span class="op">&lt;-</span> <span class="fu">searchAlgorithm</span><span class="op">(</span><span class="st">"sequentialForwardSelection"</span><span class="op">)</span></span>
<span><span class="co"># Se evalúan sobre Madrid_Sale_sample_na</span></span>
<span><span class="va">results</span> <span class="op">&lt;-</span> <span class="fu">featureSelection</span><span class="op">(</span><span class="va">Madrid_Sale_sample_na</span>, <span class="st">"price_bin"</span>, <span class="va">buscador</span>, <span class="va">evaluador</span><span class="op">)</span></span>
<span><span class="va">resultados</span><span class="op">$</span><span class="va">bestFeatures</span></span>
<span><span class="va">resultados</span><span class="op">$</span><span class="va">bestValue</span></span></code></pre></div>
<p>El resultado es el mismo que con el con el método tipo filtro anteriormente utilizado: el modelo seleccionado para explicar el comportamiento de la variable objetivo <code>price_bin</code> contiene únicamente el término independiente y una variable predictora: <code>HASTERRACE</code>.</p>
<div class="infobox">
<p><strong>Nota</strong></p>
<p>Se puede sofisticar más el modelo ajustando los parámetros del modelo con parámetros de remuestreo, que son los mismos argumentos que se pasan a la función <code><a href="https://rdrr.io/pkg/caret/man/trainControl.html">trainControl()</a></code> del paquete <code>caret.</code> En segundo lugar, se pueden establecer los parámetros de ajuste, que son los mismos que para la función de <code>train</code> de <code>caret</code>.</p>
</div>
</div>
<div id="métodos-de-selección-tipo-intrínseco-embedded" class="section level4" number="9.2.2.3">
<h4>
<span class="header-section-number">9.2.2.3</span> Métodos de selección tipo intrínseco (<em>embedded</em>) <a class="anchor" aria-label="anchor" href="#m%C3%A9todos-de-selecci%C3%B3n-tipo-intr%C3%ADnseco-embedded"><i class="fas fa-link"></i></a>
</h4>
<p>Finalmente, hay algunos algoritmos de aprendizaje automático que realizan la selección automática de variables como parte del aprendizaje del modelo. Estos son los métodos de selección de tipo intrínseco, que aglutinan las ventajas de los métodos de filtro y envoltura.</p>
<p>Un ejemplo son los relativos a los modelos de regresión penalizados, como Lasso, o <em>ridge</em> (que tienen funciones de penalización incluidas para reducir el sobreajuste), árboles de decisión y bosques aleatorios.</p>
<p>En el siguiente ejemplo se modeliza un bosque aleatorio (usando el paquete <code>randomForest</code>) y, tras dicha modelización, se identifica el conjunto óptimo de variables con la función <code><a href="https://rdrr.io/pkg/caret/man/varImp.html">varImp()</a></code> de <code>caret</code>.</p>
<div class="sourceCode" id="cb116"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://www.stat.berkeley.edu/~breiman/RandomForests/">"randomForest"</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Usar random forest para la selección de variables</span></span>
<span><span class="va">rf_modelo</span> <span class="op">&lt;-</span> <span class="fu">randomForest</span><span class="op">(</span><span class="va">price_bin</span> <span class="op">~</span> <span class="va">.</span>, data <span class="op">=</span> <span class="va">Madrid_Sale_num_sample_bin</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Listar las variables más importantes</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/caret/man/varImp.html">varImp</a></span><span class="op">(</span><span class="va">rf_modelo</span><span class="op">)</span></span></code></pre></div>
<p>Con este método de selección de variables, el modelo con mayor poder predictivo de la variable salida <code>price_bin</code> es el que contiene un término independiente y los predictores <code>CONSTRUCTEDAREA</code>, <code>ROOMNUMBER</code> y <code>BATHNUMBER</code> (ejecútese el código para comprobarlo).</p>
</div>
</div>
</div>
<div id="transformación-de-variables" class="section level2" number="9.3">
<h2>
<span class="header-section-number">9.3</span> Transformación de variables<a class="anchor" aria-label="anchor" href="#transformaci%C3%B3n-de-variables"><i class="fas fa-link"></i></a>
</h2>
<p>La transformación y creación de variables predictoras a partir de los datos en bruto tiene una componente técnica y otra más creativa; en esta última, son de gran relevancia la intuición y la experiencia en trabajos de modelado, así como el dominio de los datos en cuestión. Para labores de transformación también se utilizará el paquete <code>caret</code>.</p>
<div class="infobox">
<p><strong>Nota</strong></p>
<p><code>Caret</code> se ha elegido como herramienta principal para la parte de preprocesamiento por su amplia difusión y porque también se utiliza en la parte de <em>machine learning</em> supervisado de este libro. No obstante, se podrían usar otros paquetes, como <code>recipes</code>, incluido en <code>tidymodels</code>. Este tipo de paquetes, comúnmente llamados metapaquete (<em>meta-packages</em>), permiten agrupar varios programas junto a sus dependencias para su instalación de una vez. Por tanto, un metapaquete permite ahorrar tiempo y esfuerzo a la vez que facilita la implementación de múltiples modelos en paralelo para, posteriormente, vincular sus resultados.</p>
</div>
<p>
</p>
<p>La fase de modelización puede condicionar la fase previa de preparación de datos. Por ejemplo, determinadas técnicas imponen requisitos y expectativas sobre el tipo y forma de las variables predictoras <span class="citation">(<a href="referncias.html#ref-boehmke2019hands" role="doc-biblioref">Brad Boehmke and Greenwell 2019</a>)</span>. Así, podría ser necesario que la variable objetivo tenga una distribución de probabilidad específica, o la eliminación de variables predictoras altamente correlacionadas con otras y/o que no estén fuertemente relacionadas con la variable objetivo.</p>
<p>Generalmente, estas transformaciones son más útiles para algoritmos como los de regresión, métodos basados en instancias (también llamados <em>memory-based learning methods</em>, como <em>k</em>-vecinos más cercanos -KNN- y <em>Learning Vector Quantization</em> -LVQ-), máquinas de vectores de soporte -SVM- y redes neuronales -NN-, que para métodos basados en árboles y reglas.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Una de las varias clasificaciones existentes de los métodos de aprendizaje los divide en basados en instancias (muestras u observaciones del conjunto de entrenamiento) o en modelos. Los algoritmos basados en instancias “memorizan” dichas instancias, y utilizan esta información a la hora de realizar una predicción. El aprendizaje basado en modelos tiene como objetivo la creación de un modelo a partir de los datos de entrenamiento, con el cual se harán las predicciones.&lt;/p&gt;"><sup>68</sup></a></p>
<div id="trans-vble-obj" class="section level3" number="9.3.1">
<h3>
<span class="header-section-number">9.3.1</span> Transformación de la distribución de la variable objetivo<a class="anchor" aria-label="anchor" href="#trans-vble-obj"><i class="fas fa-link"></i></a>
</h3>
<p>Aunque no siempre es necesario, la transformación de la distribución de la variable objetivo puede llevar a una mejora predictiva significativa, especialmente en el caso de modelos paramétricos. Por ejemplo, los modelos de regresión lineal ordinarios asumen que el término de error, y, por consiguiente, la variable objetivo, se distribuyen normalmente. Pero puede ocurrir, por ejemplo, que la variable objetivo tenga valores atípicos y la suposición de normalidad no se cumpla por asimetricidad. .</p>
<!-- <!-- Para simetrizar la distribución de probabilidad de la variable objetivo, se puede usar una transformación log (entre otras -->
<!-- Esta sería una alternativa al uso de la función de pérdida del **error logarítmico cuadrático medio** (`RMSLE`) como medida de evaluación del modelo. -->
<p>Para simetrizar la distribución de probabilidad de la variable objetivo (mejorando así la dispersión de valores y, a veces, desenmascarando las relaciones lineales y aditivas entre los predictores y el objetivo) se puede usar una transformación log (entre otras). Para corregir la asimetría positiva de la distribución probabilística de la variable objetivo se suele utilizar una de las dos opciones siguientes:</p>
<ul>
<li>
<strong>Normalizar con una transformación logarítmica</strong>, que proporciona buenos resultados en la mayoría de los casos. En la Fig. <a href="chap-feature.html#fig:log">9.2</a>, se puede comprobar que, en el ejemplo que se viene arrastrando, una transformación logarítmica normaliza, en gran medida, la distribución de la variable <code>PRICE</code>. Nótese que, si la variable objetivo tiene valores negativos o cero, una transformación logarítmica producirá <span class="math inline">\(NaN\)</span> y <span class="math inline">\(- Inf\)</span>, respectivamente. Si los valores de respuesta no positivos son pequeños (por ejemplo, entre <span class="math inline">\(-0.99\)</span> y <span class="math inline">\(0\)</span>), se puede aplicar una pequeña compensación (por ejemplo, la función <code><a href="https://rdrr.io/r/base/Log.html">log1p()</a></code> agrega un 1 al valor antes de aplicar la transformación).</li>
</ul>
<div class="sourceCode" id="cb117"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">respuesta_log</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">Madrid_Sale</span><span class="op">$</span><span class="va">PRICE</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:log"></span>
<img src="img/logidealista.png" alt="Normalización logarítmica" width="60%"><p class="caption">
Figura 9.2: Normalización logarítmica
</p>
</div>
<ul>
<li><p>Como segunda opción, se puede usar una transformación de la familia de transformaciones Box-Cox (o simplemente una <strong>transformación de Box-Cox</strong>), de carácter potencial y con mayor flexibilidad que la transformación logarítmica. Generalmente, se puede encontrar la función adecuada a partir de una familia de transformadas de potencia, que llevarán la distribución de la variable transformada tan cerca como sea posible de la distribución normal [<span class="citation">Sakia (<a href="referncias.html#ref-sakia1992box" role="doc-biblioref">1992</a>)</span>]<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;La piedra angular de la transformación de Box-Cox es el exponente de dicha transformación (&lt;span class="math inline"&gt;\(\lambda\)&lt;/span&gt;), que varía entre &lt;span class="math inline"&gt;\(-5\)&lt;/span&gt; y &lt;span class="math inline"&gt;\(5\)&lt;/span&gt;.&lt;/p&gt;'><sup>69</sup></a>. No obstante, igual que la transformación logarítmica, las transformaciones del tipo Box-Cox también tienen la limitación de ser sólo aplicables a variables cuyos valores sean positivos. Por consiguiente, tanto si se usa una transformación log como una Box-Cox, no se deben centrar los datos primero, ni realizar ninguna operación que pueda hacer que los valores de la variable transformada no sean positivos.</p></li>
<li><p>En caso de valores nulos o negativos, una muy buena opción, la tercera, es la transformación Yeo-Johnson, que es una extensión de la transformación Box-Cox que no está limitada a los valores positivos.</p></li>
</ul>
<div class="sourceCode" id="cb118"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">respuesta_boxcox</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/caret/man/preProcess.html">preProcess</a></span><span class="op">(</span><span class="va">Madrid_Sale_num_sample</span>, method <span class="op">=</span> <span class="st">"BoxCox"</span><span class="op">)</span></span>
<span><span class="va">trainBC</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">respuesta_boxcox</span>, <span class="va">Madrid_Sale_num_sample</span><span class="op">)</span></span>
<span><span class="va">respuesta_boxcox</span></span>
<span><span class="co">#&gt; Created from 5000 samples and 2 variables</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; Pre-processing:</span></span>
<span><span class="co">#&gt; - Box-Cox transformation (2)</span></span>
<span><span class="co">#&gt; - ignored (0)</span></span>
<span><span class="co">#&gt;</span></span>
<span><span class="co">#&gt; Lambda estimates for Box-Cox transformation:</span></span>
<span><span class="co">#&gt; -0.3, -0.3</span></span></code></pre></div>
<p>Hay que tener en cuenta que, cuando se modela con una variable objetivo transformada, las predicciones también estarán en la escala transformada. Es posible que haya que deshacer (o volver a transformar) los valores pronosticados a su escala original, para que los responsables de la toma de decisiones puedan interpretar los resultados más fácilmente.</p>
<div class="infobox">
<p><strong>Nota</strong></p>
<p>El paquete <code>recipes</code> (recetas de cocina), incluido en <code>tidymodels</code>, permite la transformación de variables de forma secuencial. La transformación de la distribución probabilística de la variable objetivo con <code>recipes</code> se lleva a cabo en 4 etapas: <span class="math inline">\((i)\)</span> <code>recipe()</code>, donde se especifica la fórmula (variables predictoras y variable objetivo); <span class="math inline">\((ii)\)</span> <code><a href="https://rdrr.io/r/stats/step.html">step()</a></code>, donde se definen los pasos a seguir: imputación de valores perdidos, creación de variables ficticias (dummies), normalización, etc.; <span class="math inline">\((iii)\)</span> <code>prep</code> (preparar, o en otros términos, entrenar), donde que se utiliza un conjunto de datos para analizar cada paso en él; y <span class="math inline">\((iv)\)</span> <code>bake</code> (hornear/cocinar), donde, una vez aplicada la receta, se aplica al conjunto de datos. La idea detrás de <code>recipes</code> es similar a <code><a href="https://rdrr.io/pkg/caret/man/preProcess.html">caret::preProcess()</a></code>. Sin embargo, a diferencia de caret, no maneja automáticamente las variables categóricas y requiere
crear variables ficticias manualmente.</p>
<!-- Hay tres pasos principales para crear y aplicar la transformación de variables con `recipes`, *recipe* (donde se definen los pasos para crear el plan), *prep* (donde se estiman los parámetros en función de los datos de entrenamiento) y *bake* (donde se aplica el modelo a nuevos datos). Sin embargo, a diferencia de `caret`, no manejan automáticamente las variables categóricas y se requiere crear variables ficticias manualmente. -->
</div>
</div>
<div id="cambios-de-origen-y-escala-en-las-variables-normalizaciones" class="section level3" number="9.3.2">
<h3>
<span class="header-section-number">9.3.2</span> Cambios de origen y escala en las variables (normalizaciones)<a class="anchor" aria-label="anchor" href="#cambios-de-origen-y-escala-en-las-variables-normalizaciones"><i class="fas fa-link"></i></a>
</h3>
<p>La escala en que se miden las variables individuales no es una cuestión baladí a la hora de la modelización. Los modelos que incorporan funciones lineales en las variables predictoras, son sensibles a la escala de esas variables. Lo mismo puede decirse de los algoritmos que utilizan medidas de distancia, como los de agrupación y clasificación, o los de escalamiento multidimensional, entre otros; o los de reducción de la dimensionalidad. Cuando se estiman modelos, a menudo es aconsejable modificar la escala de las variables predictoras; el objetivo es evitar que unas variables tengan mayor influencia que otras en el resultado obtenido. Por ejemplo, en el conjunto de datos <code>Madrid_Sale</code> la superficie de las viviendas, medida en metros cuadrados, tiene una media y una desviación típica mayores que la antigüedad de la misma, medida en años. En consecuencia, los algoritmos basados en la magnitud de los errores pueden dar más importancia a las variables con mayor desviación típica, pero no porque tengan mayor variabilidad real que las otras, sino porque la medida de dicha variabilidad (la desviación típica) es más grande debido a la distinta escala en la que están medidas dichas variables. La consecuencia: efectos perniciosos indeseados sobre las predicción o la clasificación.</p>
<p></p>
<p>La normalización de variables tiene como objetivo que las comparaciones entre estas variables, en cuanto a su contribución al análisis de interés, sean objetivas; es decir, ponerlas en igualdad de condiciones en lo que respecta a su influencia (más allá de la que realmente tienen) en la variable objetivo.</p>
<p>La estandarización (o normalización <em>z-score</em>) es el método de normalización de variables más popular. Consiste en restar la media de la variable a sus los valores y, posteriormente, dividir esta diferencia entre la desviación típica de la variable. De esta manera, las variables (numéricas) transformadas tendrán media nula y varianza unitaria, lo que proporciona una unidad de medida comparable común a todas las variables: la distancia a la media medida en términos de desviaciones típicas.</p>
<p></p>
<p>A modo de ejemplo, a continuación se estandarizan las variables del conjunto de datos <code>Madrid_Sale</code> con la función <code><a href="https://rdrr.io/pkg/caret/man/preProcess.html">preProcess()</a></code> de <code>caret</code> y el <code>method=c('center', 'scale')</code>, de tal manera su media sea nula y su desviación típica unitaria.</p>
<div class="sourceCode" id="cb119"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prep_centrado</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/caret/man/preProcess.html">preProcess</a></span><span class="op">(</span><span class="va">Madrid_Sale_num</span>, method <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"center"</span>,<span class="st">"scale"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pred_centrado</span><span class="op">&lt;-</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">prep_centrado</span>, <span class="va">Madrid_Sale_num</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">pred_centrado</span>, n <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#&gt;       PRICE    CONSTRUCTEDAREA     ROOMNUMBER</span></span>
<span><span class="co">#1    -1.523435    -0.64763050    -0.5764192    </span></span>
<span><span class="co">#2    -1.523435    -0.38628625    0.4062338    </span></span>
<span><span class="co">#3    -1.523435    -0.05541004    0.7717038    </span></span></code></pre></div>
<p>Otra normalización también popular es la <strong>min-max</strong>, que re-escala los valores de la variable entre 0 y 1, o entre -1 y 1, y cuya expresión general es:</p>
<p><span class="math display">\[X_{norm}=\frac{X-\min(X)}{\max(X)-\min(X)}.\]</span>
</p>
<p>Si se desea re-escalar entre dos valores arbitrarios, a y b, la expresión anterior se transforma como sigue:</p>
<p><span class="math display">\[X_{norm}=a+ \frac{(X-\min(X))(b-a)}{\max(X)-\min(X)},\]</span></p>
<p>Otras opciones de normalización pueden verse en la amplia literatura sobre la cuestión.</p>
<p>Finalmente, recordar que, cuando se lleva a cabo un proceso de normalización de variables, hay que hacerlo tanto en el subconjunto de entrenamiento como en el de test, para que ambos se basen en la misma media y varianza.</p>
</div>
<div id="ingeniería-de-variables-feature-engineering" class="section level3" number="9.3.3">
<h3>
<span class="header-section-number">9.3.3</span> Ingeniería de variables (<em>feature engineering</em>) <a class="anchor" aria-label="anchor" href="#ingenier%C3%ADa-de-variables-feature-engineering"><i class="fas fa-link"></i></a>
</h3>
<p>La ingeniería de variables consiste en el proceso de conseguir, a partir de la información disponible, las variables idóneas (y el en número apropiado) para que los modelos o clasificadores proporcionen los mejores resultados posibles, dados los datos disponibles y el modelo a ejecutar. En otros términos, es el proceso de transformación de las variables seleccionadas, de forma que se obtenga el mejor rendimiento posible de los modelos de <em>machine learning</em>. Por ejemplo, transformar las variables relacionadas con la fecha de tal manera que se diferencie según el tipo de horario (“de oficina” y “de descanso”), o que se considere la cercanía al momento actual (los datos más cercanos contienen más información); los filtros de imagen (desenfocar una imagen) y la conversión de texto en números (utilizando el procesamiento avanzado del lenguaje natural, que asigna palabras a un espacio vectorial) son también ejemplos interesantes.</p>
<p>La mayoría de los modelos requieren que los predictores tengan forma numérica, por lo que, en caso de tener predictores de carácter categórico, hay que transformarlos en numéricos. Para implementar otro tipo de modelos, conviene transformar alguna(s) variable numérica en categórica. En el primer caso, conviene aplicar técnicas de <strong>agrupamiento</strong> (o <em>binning</em>), que crean agrupaciones o intervalos a partir de variables continuas; en el segundo, las técnicas de <strong>codificación</strong>, permiten tratar variables categóricas como si fueran continuas. Hay casos, como el de los modelos basados en árboles, que manejan, de manera natural, variables numéricas y categóricas; pero incluso en estos modelos se puede mejorar su rendimiento si se preprocesan las variables categóricas.</p>
<p>La identificación entre las labores de selección y de transformación de variables es bastante frecuente; sin embargo, es errónea, pues, si bien tienen algunos solapamientos, sus objetivos son claramente distintos. La ingeniería de variables tiene como objetivo la construcción de modelos más sofisticados y más interpretables que los que se pueden implementar con los datos tal y como están en el fichero raíz. La selección de variables permite que el modelo sea manejable, mejorando su interpretabilidad sin que por ello se reduzca significativamente el rendimiento del modelo.</p>
<!-- A continuación, se exponen algunos métodos de transformación de variables que generan nuevas variables, lo que aumenta la precisión del modelo y las predicciones generales. Son de dos tipos, de **agrupamiento** (o *binning*), donde se crean agrupaciones para variables continuas y de **codificación**, donde las variables numéricas se forman a partir de variables categóricas. -->
<p>
</p>
<!-- Hay dos tipos de agrupamiento, 1) no supervisado (agrupamiento automático o manual) y 2) supervisado, que implica la creación de *bins* para la variable continua mientras se tiene en cuenta también la variable objetivo. -->
<!-- Sin embargo, el *binning* debe usarse con precaución, ya que puede haber una pérdida en la precisión del modelo [@kuhn2013applied]. -->
<!-- Por su parte, la **codificación** es el proceso en el que se crean variables numéricas a partir de variables categóricas. Muchos modelos requieren que todas las variables predictoras sean numéricas. En consecuencia, se puede necesitar transformar las variables categóricas en representaciones numéricas para que estos algoritmos puedan procesarse. -->
<p>El proceso de agrupamiento ya ha sido referido e ilustrado en la Sec. <a href="chap-feature.html#metfiltro">9.2.2.1</a>. En cuanto al proceso de codificación, se pueden distinguir dos tipos:</p>
<ul>
<li>
<strong>Codificación de etiquetas</strong>: consiste en asignar a cada etiqueta un entero o valor único según el orden alfabético. Es la codificación más popular y ampliamente utilizada.</li>
<li>
<strong>Codificación one-hot</strong>: consiste en crear una nueva variable ficticia (<em>dummy</em>) binaria por cada categoría existente en la variable a codificar. Estas nuevas variables contendrán un <span class="math inline">\(1\)</span> en aquellas observaciones que pertenezcan a esa categoría, y un 0 en el resto.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;En muchas tareas, como, por ejemplo, en la regresión lineal, es común usar &lt;span class="math inline"&gt;\(k-1\)&lt;/span&gt; variables binarias en lugar de &lt;em&gt;k&lt;/em&gt;, siendo &lt;em&gt;k&lt;/em&gt; el número total de categorías. Esto se debe a que la &lt;em&gt;k&lt;/em&gt;-ésima variable binaria es redundante, ya que no es más que una combinación lineal de las otras, y, además, provocará problemas numéricos. Por otra parte, la no inclusión de dicha variable no implica pérdida de información alguna, ya que se entiende que, si el resto de las categorías contienen un &lt;span class="math inline"&gt;\(0\)&lt;/span&gt;, la categoría correspondiente es la de la categoría eliminada.&lt;/p&gt;'><sup>70</sup></a>
</li>
</ul>
<p>Para ejemplificar este tipo de codificación, a continuación, en el conjunto de datos <code>Madrid_Sale_num_sample_bin</code>, se crean <em>dummies</em>, una para cada cada categoría de las variables objeto de codificación. Para ello, se utiliza la función <code><a href="https://rdrr.io/pkg/caret/man/dummyVars.html">dummyVars()</a></code> de <code>caret</code>. El resultado puede verse con la función <code><a href="https://rdrr.io/r/stats/predict.html">predict()</a></code>.</p>
<div class="sourceCode" id="cb120"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dummies</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/caret/man/dummyVars.html">dummyVars</a></span><span class="op">(</span><span class="st">"  ~ ."</span>, data <span class="op">=</span> <span class="va">Madrid_Sale_num_sample_bin</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">dummies</span>, newdata <span class="op">=</span> <span class="va">Madrid_Sale_num_sample_bin</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>No debe olvidarse, igual que para todas las transformaciones descritas, hacer las mismas transformaciones en el conjunto de test.</p>
</div>
</div>
<div id="reducción-de-dimensionalidad" class="section level2" number="9.4">
<h2>
<span class="header-section-number">9.4</span> Reducción de dimensionalidad<a class="anchor" aria-label="anchor" href="#reducci%C3%B3n-de-dimensionalidad"><i class="fas fa-link"></i></a>
</h2>
<p>La <strong>reducción de dimensionalidad</strong> es un enfoque alternativo para filtrar las variables no informativas sin eliminarlas (como se hacía en la Sec. <a href="chap-feature.html#feature">9.2</a>, que generalmente se usa para variables numéricas. La diferencia es que las técnicas de reducción de la dimensionalidad crean una proyección de los datos que da como resultado variables predictoras completamente nuevas, que son combinaciones lineales independientes formadas a partir de las variables originales, solucionando así, también, los problemas de colinealidad y multicolinealidad (perfecta o cuasi-perfecta). Como se explica en el Cap. <a href="acp.html#acp">32</a>, el espacio de un conjunto de variables puede reducirse proyectándolo a un subespacio de variables de menor dimensión utilizando componentes principales (la técnica de reducción de la dimensionalidad por antonomasia).</p>
<div id="resumen-8" class="section level3 unnumbered infobox_resume">
<h3>Resumen<a class="anchor" aria-label="anchor" href="#resumen-8"><i class="fas fa-link"></i></a>
</h3>
<ul>
<li><p>Se presentan las principales técnicas y métodos de <em>feature selection</em> para llevar a cabo la selección (pre-selección y selección propiamente dicha) de las variables predictoras o clasificadoras más relevantes para obtener predicciones o clasificaciones exitosas.</p></li>
<li><p>Se describen las principales transformaciones que se realizan en la fase de preprocesamiento de un proyecto de modelado predictivo: las transformaciones de la escala o de la distribución de la variable objetivo, la transformación de variables (<em>feature engineering</em>) y la reducción de la dimensionalidad.</p></li>
<li><p>La creación de variables predictoras a partir de los datos en bruto tiene una componente creativa, que requiere de herramientas adecuadas y de experiencia para encontrar las mejores representaciones, apoyándose, en la medida de lo posible en el conocimiento que se tenga de los datos.</p></li>
<li><p>Las labores de selección y transformación de variables se ilustran con el conjunto de datos de <code>Madrid_Sale</code>, utilizándose los paquetes <code>caret</code> y <code>rsample</code>.</p></li>
</ul>
</div>

</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="id_130009.html"><span class="header-section-number">8</span> Integración y limpieza de datos</a></div>
<div class="next"><a href="chap-herramientas.html"><span class="header-section-number">10</span> Herramientas para el análisis en ciencia de datos</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="Índice capítulo"><h2>Índice capítulo</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#chap-feature"><span class="header-section-number">9</span> Selección y transformación de variables</a></li>
<li><a class="nav-link" href="#introducci%C3%B3n-4"><span class="header-section-number">9.1</span> Introducción</a></li>
<li>
<a class="nav-link" href="#feature"><span class="header-section-number">9.2</span> Selección de variables</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#pre-selecci%C3%B3n-de-variables"><span class="header-section-number">9.2.1</span> Pre-selección de variables</a></li>
<li><a class="nav-link" href="#m%C3%A9todos-de-selecci%C3%B3n-de-variables"><span class="header-section-number">9.2.2</span> Métodos de selección de variables</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#transformaci%C3%B3n-de-variables"><span class="header-section-number">9.3</span> Transformación de variables</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#trans-vble-obj"><span class="header-section-number">9.3.1</span> Transformación de la distribución de la variable objetivo</a></li>
<li><a class="nav-link" href="#cambios-de-origen-y-escala-en-las-variables-normalizaciones"><span class="header-section-number">9.3.2</span> Cambios de origen y escala en las variables (normalizaciones)</a></li>
<li><a class="nav-link" href="#ingenier%C3%ADa-de-variables-feature-engineering"><span class="header-section-number">9.3.3</span> Ingeniería de variables (feature engineering) </a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#reducci%C3%B3n-de-dimensionalidad"><span class="header-section-number">9.4</span> Reducción de dimensionalidad</a><ul class="nav navbar-nav"><li><a class="nav-link" href="#resumen-8">Resumen</a></li></ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Fundamentos de ciencia de datos con R</strong>" coordinado por <a href="https://blog.uclm.es/gemafaviles/" class="text-light">Gema Fernández-Avilés y José-María Montero</a>. Generado por última vez el día 2023-06-16.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>Este libro ha sido generado con el paquete de R <a class="text-light" href="https://bookdown.org">bookdown</a>.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
